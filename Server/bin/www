#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('server:server');
var http = require('http');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '8080');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);
var io = require('socket.io')(server)
/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}
const findNearestLocation = require('map-nearest-location');
var listDriver=[];
var socketHandle = require('../socketHandle');
require('events').EventEmitter.prototype._maxListeners = 20000;
const maxListenersExceededWarning = require('max-listeners-exceeded-warning');
maxListenersExceededWarning();
var checkBlackList= (list,id) =>{
  var cancelId;
  if(list.length === 0) return false
  else{
    list.forEach((value)=> {
      if(value===id) 
      {
        console.log("cancel");
        cancelId=value;
      }
    })
    return cancelId===id;
  }
}

io.on('connection',(socket=>{
    console.log("Client Connected : "+socket.id)
    socket.on('passenger',(passenger)=>
        {
          const currentArray = listDriver;
          var driverId;
          console.log(passenger);
          console.log(passenger.fromLocation);
          console.log(passenger.toLocation);
          if(currentArray.length>0){
            var listDriverLocation =[];
            currentArray.forEach((value)=>{
              console.log(checkBlackList(value.blackList,passenger.id));
              if(value.isAvailable === true && checkBlackList(value.blackList,passenger.id)===false && value.location !==null)
              listDriverLocation.push(value.location);
            })
            if(listDriverLocation.length>0)
            {
              socket.emit("list_location",{listDriver :listDriverLocation});
              console.log("list: "+ listDriverLocation);
              // const nearestLocation = findNearestLocation(passenger.fromLocation, listDriverLocation);
              const nearestLocation = findNearestLocation(passenger.fromLocation, listDriverLocation);
              console.log("----------------");
              console.log(nearestLocation);
              // var fromLocation ={lat: 11.889189040934856, lng: 108.47917556762697};
              listDriver.forEach((value,index)=> {if(value.location && value.location.lat === nearestLocation.location.lat && value.location.lng === nearestLocation.location.lng){driverId = index;}})
              console.log("----------------");
              console.log(listDriver[driverId].id);
              io.sockets.emit(listDriver[driverId].id,{phoneNumber : passenger.id, fromLocation : passenger.fromLocation, toLocation : passenger.toLocation,distance: passenger.distance});
            }
            else{
              socket.emit("unavailable",{unavailable :true});
            }
          }
          else{
            socket.emit("unavailable",{unavailable :true});
          }
        })
    socket.on('driver_on',(info)=>
        {
          console.log(info);
            var isExist = false;
            listDriver.forEach((element,index,arr) => {
              if(element.id === info.id)
              {
                arr[index].location = info.location
                isExist=true; 
                console.log("đã tồn tại, cập nhật vào!!!!!")
              }
            });
            if(isExist === false) {
              console.log("chưa tồn tại, thêm vào!!!!!");
              info.isAvailable = true;
              info.blackList = [];
              listDriver.push(info);}
            console.log(listDriver);
          }
    )
    socket.on('confirm',(res)=>{
      console.log(res);
      listDriver.forEach((element,index) => {
        if(element.id === res.id)
        {
          if(res.accept===true)
          {
            listDriver[index].isAvailable = false;
            setTimeout(()=>io.sockets.emit(res.passenger,{id :listDriver[index].id ,accept :true,info : listDriver[index].info,location : listDriver[index].location}),500);
            var interval = setInterval(()=>{
              if(listDriver[index].isAvailable===true) clearInterval(interval);
              else io.sockets.emit(res.passenger,{id :listDriver[index].id ,accept :true,info : listDriver[index].info,location : listDriver[index].location})}
              ,1500);
            console.log("đã nhan chuyen!!!!!")
          }
          else{
            listDriver[index].blackList.push(res.passenger);
            io.sockets.emit(res.passenger,{accept :false});
            console.log("da tu choi chuyen");
          }
        }
      });
      }
    )
    socket.on('complete',(res)=>{
      console.log(res);
      listDriver.forEach((element,index) => {
        if(element.id === res.driver){ 
          listDriver[index].isAvailable = true;
          if(res.complete===true)
          {
            io.sockets.emit(res.passenger,{complete :true});
          }
          else{
            io.sockets.emit(res.passenger,{complete :false});
            listDriver[index].blackList.push(res.passenger);
          }
        }
      });
      }
    )
}))



/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
